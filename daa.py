# -*- coding: utf-8 -*-
"""DAA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hdHxLfoC7Sr8gPjRaGAC2zAgi7vFOiT4
"""

stack = []
a = input("enter 1 st element ")
b = input("enter 2 nd  element ")
c = input("enter 3 rd element ")
stack.append(a) # push element
stack.append(b)
stack.append(c)

print('Initial stack')
print(stack)

print('\nElements popped from stack:')
print(stack.pop())
print(stack.pop())
print(stack.pop())

print('\nStack after elements are popped:')
print(stack)

"""#### 2. Stack using Linked List"""

class Node:
    def __init__(self, data):
        self.data = data # node
        self.next = None

class Stack:

    def __init__(self):
        self.head = None

    def isempty(self):
        if self.head == None:
            return True
        else:
            return False

    def push(self, data):
        if self.head == None:
            self.head = Node(data)
        else:
            newnode = Node(data)
            newnode.next = self.head
            self.head = newnode

    def pop(self):
        if self.isempty():
            return None
        else:
            poppednode = self.head
            self.head = self.head.next
            poppednode.next = None
            return poppednode.data

    def peek(self):
        if self.isempty():
            return None
        else:
            return self.head.data

    # Prints out the stack
    def display(self):
        iternode = self.head
        if self.isempty():
            print("Stack Underflow")
        else:
            while(iternode != None):
                print(iternode.data, end = "")
                iternode = iternode.next
                if(iternode != None):
                    print(" -> ", end = "")
            return


# Driver code
if __name__ == "__main__":
  MyStack = Stack()

  MyStack.push(61)
  MyStack.push(69)
  MyStack.push(32)
  MyStack.push(21)
  MyStack.display()

  print("\nTop element is ", MyStack.peek())

  MyStack.pop()
  MyStack.pop()

  # Display stack elements
  MyStack.display()

  # Print top element of stack
  print("\nTop element is ", MyStack.peek())

"""#### 3. Queue using Array"""

queue =[]
queue.append('a') # push element
queue.append('b')
queue.append('c')

print('Initial queue')
print(queue)

print('\nElements popped from queue: (FIFO)')
print(queue.pop(0))
print(queue.pop(0))
print(queue.pop(0))

print('\nQueue after elements are popped:')
print(queue)

"""#### 4. Queue using Linked List"""

class Node:
	def __init__(self, data):
		self.data = data
		self.next = None

class Queue:
	def __init__(self):
		self.front = self.rear = None
	def isEmpty(self):
		return self.front == None

	def EnQueue(self, item):
		temp = Node(item)

		if self.rear == None:
			self.front = self.rear = temp
			return
		self.rear.next = temp
		self.rear = temp

	def DeQueue(self):

		if self.isEmpty():
			return
		temp = self.front
		self.front = temp.next

		if(self.front == None):
			self.rear = None


# Driver Code
if __name__ == '__main__':
	q = Queue()
	q.EnQueue(10)
	q.EnQueue(20)
	q.DeQueue()
	q.DeQueue()
	q.EnQueue(30)
	q.EnQueue(40)
	q.EnQueue(50)
	q.DeQueue()
	print("Queue Front : " + str(q.front.data if q.front != None else -1))
	print("Queue Rear : " + str(q.rear.data if q.rear != None else -1))

"""#### 5. Priority Queue"""

import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def is_empty(self):
        return len(self.heap) == 0

    def enqueue(self, item, priority):
        heapq.heappush(self.heap, (priority, item))

    def dequeue(self):
        if self.is_empty():
            print("Priority Queue is empty.")
            return None
        priority, item = heapq.heappop(self.heap)
        return item

    def peek(self):
        if self.is_empty():
            print("Priority Queue is empty.")
            return None
        return self.heap[0][1]

    def display(self):
        if self.is_empty():
            print("Priority Queue is empty.")
        else:
            print("Priority Queue elements (priority, item):", self.heap)


# Example usage:
priority_queue = PriorityQueue()

priority_queue.enqueue("Task 1", 3)
priority_queue.enqueue("Task 2", 1)
priority_queue.enqueue("Task 3", 2)

priority_queue.display()

dequeued_item = priority_queue.dequeue()
print(f"Dequeued item: {dequeued_item}")

priority_queue.display()

"""#### 6. Circular Queue"""

class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = self.rear = -1

    def is_empty(self):
        return self.front == self.rear == -1

    def is_full(self):
        return (self.rear + 1) % self.capacity == self.front

    def enqueue(self, item):
        if self.is_full():
            print("Circular Queue Overflow: Cannot enqueue item, queue is full.")
            return
        elif self.is_empty():
            self.front = self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.capacity

        self.queue[self.rear] = item
        print(f"Enqueued {item} to the circular queue.")

    def dequeue(self):
        if self.is_empty():
            print("Circular Queue Underflow: Cannot dequeue item, queue is empty.")
            return None

        item = self.queue[self.front]

        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.front = (self.front + 1) % self.capacity

        print(f"Dequeued {item} from the circular queue.")
        return item

    def peek(self):
        if self.is_empty():
            print("Circular Queue is empty.")
            return None
        return self.queue[self.front]

    def display(self):
        if self.is_empty():
            print("Circular Queue is empty.")
        else:
            print("Circular Queue elements:", end=" ")
            i = self.front
            while True:
                print(self.queue[i], end=" ")
                if i == self.rear:
                    break
                i = (i + 1) % self.capacity
            print()


# Example usage:
circular_queue_capacity = 5
circular_queue = CircularQueue(circular_queue_capacity)

circular_queue.enqueue(1)
circular_queue.enqueue(2)
circular_queue.enqueue(3)
circular_queue.display()

front_item = circular_queue.peek()
print(f"Front item: {front_item}")

dequeued_item = circular_queue.dequeue()
print(f"Dequeued item: {dequeued_item}")

circular_queue.display()